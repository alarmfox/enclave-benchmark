\documentclass{article}
\usepackage{tikz, hyperref, comment, amsmath, cleveref, forest, subcaption, listings, xcolor, float}
\usepackage[bottom]{footmisc}
\usepackage[margin=.75in]{geometry}

\renewcommand{\contentsname}{Indice}
\renewcommand{\refname}{Riferimenti}
\renewcommand{\figurename}{Figura}
\renewcommand{\tablename}{Tabella}
\renewcommand{\lstlistingname}{Listato}

\crefformat{section}{\S#2#1#3}
\crefformat{subsection}{\S#2#1#3}
\crefformat{subsubsection}{\S#2#1#3}
\crefformat{figure}{#2Figura~#1#3}
\crefformat{footnote}{#2\footnotemark[#1]#3}
\crefformat{table}{#2Tabella~#1#3}

\crefname{lstlisting}{listato}{listati}
\Crefname{lstlisting}{Listato}{Listati}

\usepackage[listings,skins]{tcolorbox}
\lstdefinelanguage{Toml}{
    comment = [l]{\#},
    keywords = {true, false},
    morestring = [b]{"}
}

\lstset{
    tabsize = 2,
    frame = tb,
    breaklines = true,
    numbers = left,
    numbersep = 5pt,
    numberstyle = \color{white!30!black}\scriptsize,
    stepnumber = 1,
    basicstyle = \footnotesize\ttfamily,
    commentstyle={\color{green!50!black}\ttfamily},
    keywordstyle = {\bfseries\color{purple}}, % keywords
    keywordstyle = [2]{\itshape\color{blue}}, % traits
    keywordstyle = [3]{\color{blue}}, % primitive types
    keywordstyle = [4]{\color{blue}}, % type and value ctors
    keywordstyle = [5]{\color{purple!50!blue}}, % macros
    stringstyle = \color{green!45!blue},
    aboveskip = \baselineskip,
    showstringspaces = false
}
 \lstdefinelanguage{docker}{
  keywords={FROM, RUN, COPY, ADD, ENTRYPOINT, CMD,  ENV, ARG, WORKDIR, EXPOSE, LABEL, USER, VOLUME, STOPSIGNAL, ONBUILD, MAINTAINER, HEALTHCHECK},
  keywordstyle=\color{blue}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{\#},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\title{High performance and quantum computing}

\author{Giuseppe Capasso}

\begin{document}
\begin{titlepage}
  \thispagestyle{empty}
  \raggedright % Allinea a sinistra

  \begin{tikzpicture}
    \node[anchor=south west] at (4,0) {\includegraphics[scale=0.75]{figures/unina-logo-1.png}};
    \node[anchor=south west] at (0,1.5) {\includegraphics{figures/unina-logo-2.png}};
    \node[anchor=south west] at (0,0.5) {\textsf{Scuola Politecnica e delle Scienze di Base}};
    \node[anchor=south west] at (0,0) {\textsf{Corso di Laurea Magistrale in Ingegneria Informatica}};
  \end{tikzpicture}

  \vfill

  {\textbf{\textit{\LARGE Tracing e profiling di applicazioni SGX in Linux}}}
  \\[2cm]

  {\textbf{\textit{\Large High Performance and Quantum Computing}}}
  \\[1cm]
  {\large Anno Accademico 2024/2025}

  \vfill

  \begin{table}[h]
    \textbf{Giuseppe Capasso matr. M63001498}
  \end{table}

\end{titlepage}

\thispagestyle{empty}
\tableofcontents

\newpage
\thispagestyle{empty}

\section*{Introduzione}
L'implementazione di Trusted Execution Environment (TEE) in hardware contrasta alcuni \textit{threat model} a discapito delle performance delle applicazioni. Lo scopo di questo progetto è quello di creare un sistema che consenta di raccogliere metriche di applicazioni sia quando vengono eseguite in TEE che non per effettuarne delle comparazioni in futuro. La difficoltà principale nella raccolta metriche in questo tipo di scenari è l'uniformità. Infatti, in TEE hardware, il sistema operativo è visto come non fidato e quindi viene utilizzato in meno possibile dalle applicazioni che potrebbero disabilitare per motivi di sicurezza la raccolta metriche.
L'implementazione proposta si basa su Intel-SGX e utilizza Gramine. Gramine è uno strumento proposto da Intel per effettuare il porting di applicazioni già esistenti in TEE evitando di modificare il codice sorgente.

\clearpage
\section{Requisiti}
Il sistema che si vuole costruire deve essere in grado di orchestrare l'esecuzione di benchmark di più programmi, eseguendo ogni programma sia con Gramine che senza, variando diverse metriche. I requisiti dell'applicazione sono riassunti nella seguente tabella:

\begin{table}[h]
\centering
\begin{tabular}{|l|p{10cm}|}
\hline
\textbf{Requisito} & \textbf{Descrizione} \\ \hline
R1 & L'applicazione deve essere in grado di eseguire programmi in un ambiente Trusted Execution Environment (TEE) utilizzando Gramine. \\ \hline
R2 & L'applicazione deve eseguire gli stessi programmi anche al di fuori del TEE per consentire il confronto delle prestazioni. \\ \hline
R3 & Deve essere possibile variare le metriche di esecuzione, come il numero di thread, la quantità di memoria allocata, e altre risorse di sistema. \\ \hline
R4 & L'applicazione deve raccogliere metriche di performance durante l'esecuzione dei programmi, sia in TEE che non. \\ \hline
R5 & Deve essere garantita l'uniformità nella raccolta delle metriche, indipendentemente dall'ambiente di esecuzione. \\ \hline
R6 & L'applicazione deve fornire un'interfaccia per configurare e avviare i benchmark in modo automatizzato. \\ \hline
R7 & I risultati dei benchmark devono essere salvati in un formato che consenta un'analisi successiva. \\ \hline
R8 & L'applicazione deve essere in grado di gestire errori e anomalie durante l'esecuzione dei benchmark, fornendo log dettagliati. \\ \hline
R9 & Deve essere possibile eseguire benchmark su diverse piattaforme hardware supportate da Intel-SGX. \\ \hline
\end{tabular}
\caption{Requisiti dell'applicazione per il benchmarking in TEE e non-TEE}
\end{table}

Il benchmark si divide in due tipi principali: Macro benchmark e Micro benchmark. In questa sezione ci concentreremo sui parametri del Macro benchmark, che riguardano l'esecuzione in enclave. I parametri considerati sono i seguenti:

\begin{table}[h]
\centering
\begin{tabular}{|l|p{6cm}|p{6cm}|}
\hline
\textbf{Parametro} & \textbf{Descrizione} & \textbf{Note} \\ \hline
Enclave & Indica se l'esecuzione avviene all'interno di un enclave (Sì/No). & \\ \hline
Memoria Enclave & La quantità di memoria dedicata all'enclave, con valori come "256M". &  A seconda della versione di SGX considerata questo comporterà l'allocazione statica (SGX1) o dinamica (SGX2) della memoria. La memoria EPC ha una grandezza standard che viene configurata dal BIOS e può essere di 64M o 128M  \\ \hline
Numero di thread & Il numero di thread utilizzati dal programma durante l'esecuzione. & A seconda della versione di SGX il numero di thread può crescere staticamente o dinamicamente. Per SGX1, un'enclave ha bisogno di almeno $4$ thread per eseguire (gestore Gramine, servizi di attestazione remota etc.); mentre SGX2 può creare dinamicamente i thread quando c'è bisogno \\ \hline
Tipo di storage & Specifica se lo storage è non fidato (untrusted) o cifrato (encrypted). & \\ \hline
\end{tabular}
\caption{Parametri del Macro benchmark}
\end{table}

Questi parametri sono fondamentali per valutare le prestazioni delle applicazioni quando vengono eseguite in un ambiente Trusted Execution Environment (TEE) utilizzando Gramine. La configurazione di questi parametri consente di analizzare l'impatto delle diverse risorse e configurazioni sull'efficienza e la sicurezza delle applicazioni.

I parametri del micro benchmark sono fondamentali per analizzare il comportamento dettagliato delle applicazioni. I parametri considerati sono i seguenti:

\begin{table}[h]
\centering
\begin{tabular}{|l|p{6cm}|p{6cm}|}
\hline
\textbf{Parametro} & \textbf{Descrizione} & \textbf{Note} \\ \hline
Consumo energetico & Misura l'energia consumata durante l'esecuzione di applicazioni Gramine e non &  \\ \hline
Tracce di esecuzione & Raccoglie le tracce di esecuzione per analizzare il flusso del programma. &  \\ \hline
Pattern di accesso & Analizza i pattern di accesso alla memoria e alle risorse. &  \\ \hline
\end{tabular}
\caption{Parametri del Micro benchmark}
\end{table}

\clearpage
\section{Strumenti per il profiling in Linux}

In questo capitolo si analizzano i principali strumenti messi a disposizione da Linux per il monitoraggio e l'analisi delle prestazioni dei sistemi. In particolare, verranno esaminati i meccanismi basati sui performance counters, le tecniche di misurazione dell'energia e il tracing a livello kernel tramite eBPF.

\subsection{Performance counters}

I performance counters sono strumenti hardware che consentono di monitorare eventi interni alla CPU, come il numero di cicli, cache misses e altri eventi critici per l'analisi delle prestazioni. Linux fornisce l'interfaccia \texttt{perf}, utilizzabile sia come utility da linea di comando sia in maniera programmatica tramite la system call \texttt{perf\_event\_open}.

La system call \texttt{perf\_event\_open} apre un descrittore di file che rappresenta un contatore di performance. La struttura \texttt{perf\_event\_attr} viene utilizzata per specificare il tipo di evento da monitorare (ad es. cicli CPU, eventi hardware, ecc.), le modalità di raccolta e altre opzioni, come l'esclusione delle attività in kernel o in ambienti virtualizzati.

Di seguito è riportato uno snippet di codice in C che illustra un esempio basilare di utilizzo di \texttt{perf\_event\_open} per monitorare il numero di cicli della CPU:

\begin{lstlisting}[language=C, caption={Esempio di utilizzo di \texttt{perf\_event\_open} per contare i cicli CPU}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <linux/perf_event.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>
#include <asm/unistd.h>
#include <errno.h>

/* Funzione wrapper per la system call perf_event_open */
static long
perf_event_open(struct perf_event_attr *hw_event, pid_t pid, int cpu,
                int group_fd, unsigned long flags)
{
    return syscall(__NR_perf_event_open, hw_event, pid, cpu, group_fd, flags);
}

int main(void)
{
    struct perf_event_attr pe;
    long fd;
    long long count;

    /* Inizializza la struttura a zero e configura l'evento da monitorare */
    memset(&pe, 0, sizeof(struct perf_event_attr));
    pe.type = PERF_TYPE_HARDWARE;
    pe.size = sizeof(struct perf_event_attr);
    pe.config = PERF_COUNT_HW_CPU_CYCLES;
    pe.disabled = 1;
    pe.exclude_kernel = 1; /* Esclude il codice kernel */
    pe.exclude_hv = 1;     /* Esclude la virtualizzazione */

    /* Apre il contatore per il processo corrente su tutti i core (-1) */
    fd = perf_event_open(&pe, 0, -1, -1, 0);
    if (fd == -1) {
        perror("perf_event_open");
        exit(EXIT_FAILURE);
    }

    /* Resetta e abilita il contatore */
    ioctl(fd, PERF_EVENT_IOC_RESET, 0);
    ioctl(fd, PERF_EVENT_IOC_ENABLE, 0);

    /* Inserire qui il lavoro da monitorare */
    sleep(1);

    /* Disabilita il contatore e legge il valore */
    ioctl(fd, PERF_EVENT_IOC_DISABLE, 0);
    read(fd, &count, sizeof(long long));
    printf("CPU cycles: %lld\n", count);

    close(fd);
    return 0;
}
\end{lstlisting}

In questo esempio, la struttura \texttt{perf\_event\_attr} viene configurata per contare i cicli CPU (\texttt{PERF\_COUNT\_HW\_CPU\_CYCLES}) escludendo il codice kernel e le operazioni in ambienti virtualizzati. Dopo aver aperto il contatore tramite \texttt{perf\_event\_open}, il contatore viene resettato, abilitato, e successivamente disabilitato per leggere il valore accumulato, che viene stampato a video.

\subsection{Misurazione dell'energia}
La tecnologia \emph{Running Average Power Limit (RAPL)} consente di monitorare il consumo energetico del sistema suddividendolo in in domini di potenza, quali \textit{package}, \textit{core}, \textit{uncore} e \textit{DRAM},  sfruttando contatori hardware che vengono incrementati in base alla corrente e alla tensione misurate. Questi contatori forniscono una stima dell'energia consumata, espressa in microjoule, e sono esposti dal kernel Linux tramite il filesystem \texttt{sysfs}.


\paragraph{Interfaccia Sysfs e struttura delle directory}

L'interfaccia RAPL è accessibile in Linux all'interno della directory:

\begin{forest}
for tree={
    font=\ttfamily,
    grow'=0,
    child anchor=west,
    parent anchor=south,
    anchor=west,
    calign=first,
    edge path={
      \noexpand\path [draw, \forestoption{edge}]
      (!u.south west) +(7.5pt,0) |- node[fill,inner sep=1.25pt] {} (.child anchor)\forestoption{edge label};
    },
    before typesetting nodes={
      if n=1
        {insert before={[,phantom]}}
        {}
    },
    fit=band,
    before computing xy={l=15pt},
  }
  [/sys/devices/virtual/powercap
          [intel-rapl
            [enabled]
            [intel-rapl:i
              [enabled]
              [energy\_uj]
              [max\_energy\_range\_uj]
              [name]
              [intel-rapl:i:j
                [enabled]
                [energy\_uj]
                [max\_energy\_range\_uj]
                [name]
              ]
            ]
          ]
        ]
      ]
    ]
  ]
\end{forest}

In questa struttura, l'indice \texttt{i} rappresenta il dominio energetico principale (ad esempio, un package CPU) e l'indice \texttt{j} identifica eventuali sotto-domini (ad esempio, i core interni o la DRAM). Il file \texttt{energy\_uj} contiene il valore cumulativo dell'energia consumata in microjoule, mentre \texttt{max\_energy\_range\_uj} specifica il massimo valore raggiungibile prima che il contatore si resetti.

\paragraph{Implementazione e limiti di RAPL}

I contatori RAPL sono implementati direttamente in hardware:  
\begin{itemize}
    \item \textbf{Misurazione hardware:} Il consumo energetico viene stimato in base alla corrente e alla tensione rilevate da sensori integrati, aggiornando continuamente i contatori.
    \item \textbf{Modelli interni:} I valori riportati sono basati su modelli interni del processore, il che può comportare una certa discrepanza rispetto al consumo reale, soprattutto in condizioni di carico variabile.
    \item \textbf{Risoluzione e wrap-around:} La risoluzione tipica in microjoule potrebbe non essere sufficiente per analisi ad altissima frequenza, e, essendo contatori cumulativi, se non letti con sufficiente frequenza, possono raggiungere il loro limite massimo e conseguentemente "wrap-around", rendendo necessaria una gestione attenta per evitare errori di interpretazione.
\end{itemize}

\subsection{Tracing a livello kernel: eBPF}

L'estensione \emph{extended Berkeley Packet Filter (eBPF)} rappresenta una tecnologia avanzata per il tracing a livello kernel. Essa consente l'esecuzione di piccoli programmi, scritti tipicamente in C, direttamente all'interno del kernel in modalità sandbox.  
Questi programmi possono essere attaccati a specifici eventi (ad esempio, l'entrata in una system call come \texttt{read}) e sono in grado di raccogliere informazioni a basso livello, quali i tempi di esecuzione, le operazioni I/O e l'allocazione della memoria.  
I dati raccolti vengono memorizzati in apposite strutture (chiamate \emph{mappe}), che facilitano il trasferimento delle informazioni dal kernel allo spazio utente.  
Un'ulteriore funzionalità, denominata \emph{deep tracing}, permette di acquisire metriche ancora più dettagliate, sfruttando meccanismi quali i \emph{ring buffer} per il trasferimento asincrono degli eventi. Questa capacità di effettuare un'analisi fine del comportamento del sistema rende eBPF uno strumento indispensabile per il profiling in ambienti complessi e ad alte prestazioni.

\vspace{1em}
\noindent\textbf{Nota:} Per ulteriori dettagli tecnici e specifiche implementative si rimanda alla documentazione completa, che può essere consultata come fonte di riferimento.

\clearpage
\section{Implementazione}
\subsection{Applicazione CLI in Rust}
\subsubsection{Installazione}
\subsubsection{Configurazione}
\subsection{Demo}

\clearpage
\pagestyle{plain}
\pagenumbering{roman}
\setcounter{page}{1}
\addcontentsline{toc}{section}{Riferimenti}
\bibliographystyle{plain}
\bibliography{refs}

\end{document}
